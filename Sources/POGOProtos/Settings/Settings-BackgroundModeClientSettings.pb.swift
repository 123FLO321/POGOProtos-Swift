// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: POGOProtos/Settings/BackgroundModeClientSettings.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct POGOProtos_Settings_BackgroundModeClientSettings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var maximumSampleAgeMs: Int64 = 0

  public var acceptManualFitnessSamples: Bool = false

  public var minimumLocationAccuracyMeters: Double = 0

  public var backgroundWakeUpIntervalMinutes: Int32 = 0

  public var maxUploadSizeInBytes: Int32 = 0

  public var minEnclosingGeofenceRadiusM: Double = 0

  public var backgroundTokenRefreshIntervalS: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "POGOProtos.Settings"

extension POGOProtos_Settings_BackgroundModeClientSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BackgroundModeClientSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "maximum_sample_age_ms"),
    2: .standard(proto: "accept_manual_fitness_samples"),
    3: .standard(proto: "minimum_location_accuracy_meters"),
    4: .standard(proto: "background_wake_up_interval_minutes"),
    5: .standard(proto: "max_upload_size_in_bytes"),
    6: .standard(proto: "min_enclosing_geofence_radius_m"),
    7: .standard(proto: "background_token_refresh_interval_s"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maximumSampleAgeMs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.acceptManualFitnessSamples) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.minimumLocationAccuracyMeters) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.backgroundWakeUpIntervalMinutes) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxUploadSizeInBytes) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.minEnclosingGeofenceRadiusM) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.backgroundTokenRefreshIntervalS) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maximumSampleAgeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.maximumSampleAgeMs, fieldNumber: 1)
    }
    if self.acceptManualFitnessSamples != false {
      try visitor.visitSingularBoolField(value: self.acceptManualFitnessSamples, fieldNumber: 2)
    }
    if self.minimumLocationAccuracyMeters != 0 {
      try visitor.visitSingularDoubleField(value: self.minimumLocationAccuracyMeters, fieldNumber: 3)
    }
    if self.backgroundWakeUpIntervalMinutes != 0 {
      try visitor.visitSingularInt32Field(value: self.backgroundWakeUpIntervalMinutes, fieldNumber: 4)
    }
    if self.maxUploadSizeInBytes != 0 {
      try visitor.visitSingularInt32Field(value: self.maxUploadSizeInBytes, fieldNumber: 5)
    }
    if self.minEnclosingGeofenceRadiusM != 0 {
      try visitor.visitSingularDoubleField(value: self.minEnclosingGeofenceRadiusM, fieldNumber: 6)
    }
    if self.backgroundTokenRefreshIntervalS != 0 {
      try visitor.visitSingularInt64Field(value: self.backgroundTokenRefreshIntervalS, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Settings_BackgroundModeClientSettings, rhs: POGOProtos_Settings_BackgroundModeClientSettings) -> Bool {
    if lhs.maximumSampleAgeMs != rhs.maximumSampleAgeMs {return false}
    if lhs.acceptManualFitnessSamples != rhs.acceptManualFitnessSamples {return false}
    if lhs.minimumLocationAccuracyMeters != rhs.minimumLocationAccuracyMeters {return false}
    if lhs.backgroundWakeUpIntervalMinutes != rhs.backgroundWakeUpIntervalMinutes {return false}
    if lhs.maxUploadSizeInBytes != rhs.maxUploadSizeInBytes {return false}
    if lhs.minEnclosingGeofenceRadiusM != rhs.minEnclosingGeofenceRadiusM {return false}
    if lhs.backgroundTokenRefreshIntervalS != rhs.backgroundTokenRefreshIntervalS {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
