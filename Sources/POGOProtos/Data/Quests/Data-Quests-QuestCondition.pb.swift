// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: POGOProtos/Data/Quests/QuestCondition.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct POGOProtos_Data_Quests_QuestCondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: POGOProtos_Data_Quests_QuestCondition.ConditionType = .unset

  public var condition: POGOProtos_Data_Quests_QuestCondition.OneOf_Condition? = nil

  public var withPokemonType: POGOProtos_Data_Quests_QuestCondition.WithPokemonType {
    get {
      if case .withPokemonType(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithPokemonType()
    }
    set {condition = .withPokemonType(newValue)}
  }

  public var withPokemonCategory: POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory {
    get {
      if case .withPokemonCategory(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory()
    }
    set {condition = .withPokemonCategory(newValue)}
  }

  public var withWeatherBoost: POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost {
    get {
      if case .withWeatherBoost(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost()
    }
    set {condition = .withWeatherBoost(newValue)}
  }

  public var withDailyCaptureBonus: POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus {
    get {
      if case .withDailyCaptureBonus(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus()
    }
    set {condition = .withDailyCaptureBonus(newValue)}
  }

  public var withDailySpinBonus: POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus {
    get {
      if case .withDailySpinBonus(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus()
    }
    set {condition = .withDailySpinBonus(newValue)}
  }

  public var withWinRaidStatus: POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus {
    get {
      if case .withWinRaidStatus(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus()
    }
    set {condition = .withWinRaidStatus(newValue)}
  }

  public var withRaidLevel: POGOProtos_Data_Quests_QuestCondition.WithRaidLevel {
    get {
      if case .withRaidLevel(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithRaidLevel()
    }
    set {condition = .withRaidLevel(newValue)}
  }

  public var withThrowType: POGOProtos_Data_Quests_QuestCondition.WithThrowType {
    get {
      if case .withThrowType(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithThrowType()
    }
    set {condition = .withThrowType(newValue)}
  }

  public var withWinGymBattleStatus: POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus {
    get {
      if case .withWinGymBattleStatus(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus()
    }
    set {condition = .withWinGymBattleStatus(newValue)}
  }

  public var withSuperEffectiveChargeMove: POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove {
    get {
      if case .withSuperEffectiveChargeMove(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove()
    }
    set {condition = .withSuperEffectiveChargeMove(newValue)}
  }

  public var withItem: POGOProtos_Data_Quests_QuestCondition.WithItem {
    get {
      if case .withItem(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithItem()
    }
    set {condition = .withItem(newValue)}
  }

  public var withUniquePokestop: POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop {
    get {
      if case .withUniquePokestop(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop()
    }
    set {condition = .withUniquePokestop(newValue)}
  }

  public var withQuestContext: POGOProtos_Data_Quests_QuestCondition.WithQuestContext {
    get {
      if case .withQuestContext(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithQuestContext()
    }
    set {condition = .withQuestContext(newValue)}
  }

  public var withBadgeType: POGOProtos_Data_Quests_QuestCondition.WithBadgeType {
    get {
      if case .withBadgeType(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithBadgeType()
    }
    set {condition = .withBadgeType(newValue)}
  }

  public var withPlayerLevel: POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel {
    get {
      if case .withPlayerLevel(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel()
    }
    set {condition = .withPlayerLevel(newValue)}
  }

  public var withWinBattleStatus: POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus {
    get {
      if case .withWinBattleStatus(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus()
    }
    set {condition = .withWinBattleStatus(newValue)}
  }

  public var withUniquePokemon: POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon {
    get {
      if case .withUniquePokemon(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon()
    }
    set {condition = .withUniquePokemon(newValue)}
  }

  public var withNpcCombat: POGOProtos_Data_Quests_QuestCondition.WithNpcCombat {
    get {
      if case .withNpcCombat(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithNpcCombat()
    }
    set {condition = .withNpcCombat(newValue)}
  }

  public var withPvpCombat: POGOProtos_Data_Quests_QuestCondition.WithPvpCombat {
    get {
      if case .withPvpCombat(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithPvpCombat()
    }
    set {condition = .withPvpCombat(newValue)}
  }

  public var withLocation: POGOProtos_Data_Quests_QuestCondition.WithLocation {
    get {
      if case .withLocation(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithLocation()
    }
    set {condition = .withLocation(newValue)}
  }

  public var withDistance: POGOProtos_Data_Quests_QuestCondition.WithDistance {
    get {
      if case .withDistance(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithDistance()
    }
    set {condition = .withDistance(newValue)}
  }

  public var withInvasionCharacter: POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter {
    get {
      if case .withInvasionCharacter(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter()
    }
    set {condition = .withInvasionCharacter(newValue)}
  }

  public var withPokemonAlignment: POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment {
    get {
      if case .withPokemonAlignment(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment()
    }
    set {condition = .withPokemonAlignment(newValue)}
  }

  public var withBuddy: POGOProtos_Data_Quests_QuestCondition.WithBuddy {
    get {
      if case .withBuddy(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithBuddy()
    }
    set {condition = .withBuddy(newValue)}
  }

  public var withDailyBuddyAffection: POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection {
    get {
      if case .withDailyBuddyAffection(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection()
    }
    set {condition = .withDailyBuddyAffection(newValue)}
  }

  public var withPokemonLevel: POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel {
    get {
      if case .withPokemonLevel(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel()
    }
    set {condition = .withPokemonLevel(newValue)}
  }

  public var withMaxCp: POGOProtos_Data_Quests_QuestCondition.WithMaxCp {
    get {
      if case .withMaxCp(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithMaxCp()
    }
    set {condition = .withMaxCp(newValue)}
  }

  public var withTempEvoID: POGOProtos_Data_Quests_QuestCondition.WithTempEvoId {
    get {
      if case .withTempEvoID(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithTempEvoId()
    }
    set {condition = .withTempEvoID(newValue)}
  }

  public var withGblRank: POGOProtos_Data_Quests_QuestCondition.WithGblRank {
    get {
      if case .withGblRank(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithGblRank()
    }
    set {condition = .withGblRank(newValue)}
  }

  public var withEncounterType: POGOProtos_Data_Quests_QuestCondition.WithEncounterType {
    get {
      if case .withEncounterType(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithEncounterType()
    }
    set {condition = .withEncounterType(newValue)}
  }

  public var withCombatType: POGOProtos_Data_Quests_QuestCondition.WithCombatType {
    get {
      if case .withCombatType(let v)? = condition {return v}
      return POGOProtos_Data_Quests_QuestCondition.WithCombatType()
    }
    set {condition = .withCombatType(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Condition: Equatable {
    case withPokemonType(POGOProtos_Data_Quests_QuestCondition.WithPokemonType)
    case withPokemonCategory(POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory)
    case withWeatherBoost(POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost)
    case withDailyCaptureBonus(POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus)
    case withDailySpinBonus(POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus)
    case withWinRaidStatus(POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus)
    case withRaidLevel(POGOProtos_Data_Quests_QuestCondition.WithRaidLevel)
    case withThrowType(POGOProtos_Data_Quests_QuestCondition.WithThrowType)
    case withWinGymBattleStatus(POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus)
    case withSuperEffectiveChargeMove(POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove)
    case withItem(POGOProtos_Data_Quests_QuestCondition.WithItem)
    case withUniquePokestop(POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop)
    case withQuestContext(POGOProtos_Data_Quests_QuestCondition.WithQuestContext)
    case withBadgeType(POGOProtos_Data_Quests_QuestCondition.WithBadgeType)
    case withPlayerLevel(POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel)
    case withWinBattleStatus(POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus)
    case withUniquePokemon(POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon)
    case withNpcCombat(POGOProtos_Data_Quests_QuestCondition.WithNpcCombat)
    case withPvpCombat(POGOProtos_Data_Quests_QuestCondition.WithPvpCombat)
    case withLocation(POGOProtos_Data_Quests_QuestCondition.WithLocation)
    case withDistance(POGOProtos_Data_Quests_QuestCondition.WithDistance)
    case withInvasionCharacter(POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter)
    case withPokemonAlignment(POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment)
    case withBuddy(POGOProtos_Data_Quests_QuestCondition.WithBuddy)
    case withDailyBuddyAffection(POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection)
    case withPokemonLevel(POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel)
    case withMaxCp(POGOProtos_Data_Quests_QuestCondition.WithMaxCp)
    case withTempEvoID(POGOProtos_Data_Quests_QuestCondition.WithTempEvoId)
    case withGblRank(POGOProtos_Data_Quests_QuestCondition.WithGblRank)
    case withEncounterType(POGOProtos_Data_Quests_QuestCondition.WithEncounterType)
    case withCombatType(POGOProtos_Data_Quests_QuestCondition.WithCombatType)

  #if !swift(>=4.1)
    public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.OneOf_Condition, rhs: POGOProtos_Data_Quests_QuestCondition.OneOf_Condition) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.withPokemonType, .withPokemonType): return {
        guard case .withPokemonType(let l) = lhs, case .withPokemonType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withPokemonCategory, .withPokemonCategory): return {
        guard case .withPokemonCategory(let l) = lhs, case .withPokemonCategory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withWeatherBoost, .withWeatherBoost): return {
        guard case .withWeatherBoost(let l) = lhs, case .withWeatherBoost(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withDailyCaptureBonus, .withDailyCaptureBonus): return {
        guard case .withDailyCaptureBonus(let l) = lhs, case .withDailyCaptureBonus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withDailySpinBonus, .withDailySpinBonus): return {
        guard case .withDailySpinBonus(let l) = lhs, case .withDailySpinBonus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withWinRaidStatus, .withWinRaidStatus): return {
        guard case .withWinRaidStatus(let l) = lhs, case .withWinRaidStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withRaidLevel, .withRaidLevel): return {
        guard case .withRaidLevel(let l) = lhs, case .withRaidLevel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withThrowType, .withThrowType): return {
        guard case .withThrowType(let l) = lhs, case .withThrowType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withWinGymBattleStatus, .withWinGymBattleStatus): return {
        guard case .withWinGymBattleStatus(let l) = lhs, case .withWinGymBattleStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withSuperEffectiveChargeMove, .withSuperEffectiveChargeMove): return {
        guard case .withSuperEffectiveChargeMove(let l) = lhs, case .withSuperEffectiveChargeMove(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withItem, .withItem): return {
        guard case .withItem(let l) = lhs, case .withItem(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withUniquePokestop, .withUniquePokestop): return {
        guard case .withUniquePokestop(let l) = lhs, case .withUniquePokestop(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withQuestContext, .withQuestContext): return {
        guard case .withQuestContext(let l) = lhs, case .withQuestContext(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withBadgeType, .withBadgeType): return {
        guard case .withBadgeType(let l) = lhs, case .withBadgeType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withPlayerLevel, .withPlayerLevel): return {
        guard case .withPlayerLevel(let l) = lhs, case .withPlayerLevel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withWinBattleStatus, .withWinBattleStatus): return {
        guard case .withWinBattleStatus(let l) = lhs, case .withWinBattleStatus(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withUniquePokemon, .withUniquePokemon): return {
        guard case .withUniquePokemon(let l) = lhs, case .withUniquePokemon(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withNpcCombat, .withNpcCombat): return {
        guard case .withNpcCombat(let l) = lhs, case .withNpcCombat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withPvpCombat, .withPvpCombat): return {
        guard case .withPvpCombat(let l) = lhs, case .withPvpCombat(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withLocation, .withLocation): return {
        guard case .withLocation(let l) = lhs, case .withLocation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withDistance, .withDistance): return {
        guard case .withDistance(let l) = lhs, case .withDistance(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withInvasionCharacter, .withInvasionCharacter): return {
        guard case .withInvasionCharacter(let l) = lhs, case .withInvasionCharacter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withPokemonAlignment, .withPokemonAlignment): return {
        guard case .withPokemonAlignment(let l) = lhs, case .withPokemonAlignment(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withBuddy, .withBuddy): return {
        guard case .withBuddy(let l) = lhs, case .withBuddy(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withDailyBuddyAffection, .withDailyBuddyAffection): return {
        guard case .withDailyBuddyAffection(let l) = lhs, case .withDailyBuddyAffection(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withPokemonLevel, .withPokemonLevel): return {
        guard case .withPokemonLevel(let l) = lhs, case .withPokemonLevel(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withMaxCp, .withMaxCp): return {
        guard case .withMaxCp(let l) = lhs, case .withMaxCp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withTempEvoID, .withTempEvoID): return {
        guard case .withTempEvoID(let l) = lhs, case .withTempEvoID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withGblRank, .withGblRank): return {
        guard case .withGblRank(let l) = lhs, case .withGblRank(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withEncounterType, .withEncounterType): return {
        guard case .withEncounterType(let l) = lhs, case .withEncounterType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.withCombatType, .withCombatType): return {
        guard case .withCombatType(let l) = lhs, case .withCombatType(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public enum ConditionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unset // = 0
    case withPokemonType // = 1
    case withPokemonCategory // = 2
    case withWeatherBoost // = 3
    case withDailyCaptureBonus // = 4
    case withDailySpinBonus // = 5
    case withWinRaidStatus // = 6
    case withRaidLevel // = 7
    case withThrowType // = 8
    case withWinGymBattleStatus // = 9
    case withSuperEffectiveCharge // = 10
    case withItem // = 11
    case withUniquePokestop // = 12
    case withQuestContext // = 13
    case withThrowTypeInARow // = 14
    case withCurveBall // = 15
    case withBadgeType // = 16
    case withPlayerLevel // = 17
    case withWinBattleStatus // = 18
    case withNewFriend // = 19
    case withDaysInARow // = 20
    case withUniquePokemon // = 21
    case withNpcCombat // = 22
    case withPvpCombat // = 23
    case withLocation // = 24
    case withDistance // = 25
    case withPokemonAlignment // = 26
    case withInvasionCharacter // = 27
    case withBuddy // = 28
    case withBuddyInterestingPoi // = 29
    case withDailyBuddyAffection // = 30
    case withPokemonLevel // = 31
    case withSingleDay // = 32
    case withUniquePokemonTeam // = 33
    case withMaxCp // = 34
    case withLuckyPokemon // = 35
    case withLegendaryPokemon // = 36
    case withTempEvoPokemon // = 37
    case withGblRank // = 38
    case withCatchesInARow // = 39
    case withEncounterType // = 40
    case withCombatType // = 41
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .withPokemonType
      case 2: self = .withPokemonCategory
      case 3: self = .withWeatherBoost
      case 4: self = .withDailyCaptureBonus
      case 5: self = .withDailySpinBonus
      case 6: self = .withWinRaidStatus
      case 7: self = .withRaidLevel
      case 8: self = .withThrowType
      case 9: self = .withWinGymBattleStatus
      case 10: self = .withSuperEffectiveCharge
      case 11: self = .withItem
      case 12: self = .withUniquePokestop
      case 13: self = .withQuestContext
      case 14: self = .withThrowTypeInARow
      case 15: self = .withCurveBall
      case 16: self = .withBadgeType
      case 17: self = .withPlayerLevel
      case 18: self = .withWinBattleStatus
      case 19: self = .withNewFriend
      case 20: self = .withDaysInARow
      case 21: self = .withUniquePokemon
      case 22: self = .withNpcCombat
      case 23: self = .withPvpCombat
      case 24: self = .withLocation
      case 25: self = .withDistance
      case 26: self = .withPokemonAlignment
      case 27: self = .withInvasionCharacter
      case 28: self = .withBuddy
      case 29: self = .withBuddyInterestingPoi
      case 30: self = .withDailyBuddyAffection
      case 31: self = .withPokemonLevel
      case 32: self = .withSingleDay
      case 33: self = .withUniquePokemonTeam
      case 34: self = .withMaxCp
      case 35: self = .withLuckyPokemon
      case 36: self = .withLegendaryPokemon
      case 37: self = .withTempEvoPokemon
      case 38: self = .withGblRank
      case 39: self = .withCatchesInARow
      case 40: self = .withEncounterType
      case 41: self = .withCombatType
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .withPokemonType: return 1
      case .withPokemonCategory: return 2
      case .withWeatherBoost: return 3
      case .withDailyCaptureBonus: return 4
      case .withDailySpinBonus: return 5
      case .withWinRaidStatus: return 6
      case .withRaidLevel: return 7
      case .withThrowType: return 8
      case .withWinGymBattleStatus: return 9
      case .withSuperEffectiveCharge: return 10
      case .withItem: return 11
      case .withUniquePokestop: return 12
      case .withQuestContext: return 13
      case .withThrowTypeInARow: return 14
      case .withCurveBall: return 15
      case .withBadgeType: return 16
      case .withPlayerLevel: return 17
      case .withWinBattleStatus: return 18
      case .withNewFriend: return 19
      case .withDaysInARow: return 20
      case .withUniquePokemon: return 21
      case .withNpcCombat: return 22
      case .withPvpCombat: return 23
      case .withLocation: return 24
      case .withDistance: return 25
      case .withPokemonAlignment: return 26
      case .withInvasionCharacter: return 27
      case .withBuddy: return 28
      case .withBuddyInterestingPoi: return 29
      case .withDailyBuddyAffection: return 30
      case .withPokemonLevel: return 31
      case .withSingleDay: return 32
      case .withUniquePokemonTeam: return 33
      case .withMaxCp: return 34
      case .withLuckyPokemon: return 35
      case .withLegendaryPokemon: return 36
      case .withTempEvoPokemon: return 37
      case .withGblRank: return 38
      case .withCatchesInARow: return 39
      case .withEncounterType: return 40
      case .withCombatType: return 41
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct WithCombatType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var combatType: [POGOProtos_Enums_CombatType] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithEncounterType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var encounterType: [POGOProtos_Enums_EncounterType] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithGblRank {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var rank: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithTempEvoId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var megaForm: [POGOProtos_Enums_TemporaryEvolutionId] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithMaxCp {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var maxCp: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithPokemonLevel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var maxLevel: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithDailyBuddyAffection {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var minBuddyAffectionEarnedToday: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithBuddy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var minBuddyLevel: POGOProtos_Enums_BuddyLevel = .unset

    public var mustBeOnMap: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithPokemonAlignment {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var alignment: [POGOProtos_Data_PokemonDisplay.Alignment] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithInvasionCharacter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var category: [POGOProtos_Enums_EnumWrapper.CharacterCategory] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithUniquePokemon {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithPvpCombat {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var requiresWin: Bool = false

    public var combatLeagueTemplateID: [String] = []

    public var combatLeagueBadge: POGOProtos_Enums_BadgeType = .badgeUnset

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithNpcCombat {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var requiresWin: Bool = false

    public var combatNpcTrainerID: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithLocation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var s2CellID: [Int64] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithDistance {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var distanceKm: Double = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithPokemonType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pokemonType: [POGOProtos_Enums_PokemonType] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithWeatherBoost {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithPokemonCategory {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var categoryName: String = String()

    public var pokemonIds: [POGOProtos_Enums_PokemonId] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithDailyCaptureBonus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithDailySpinBonus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithWinRaidStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithRaidLevel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var raidLevel: [POGOProtos_Enums_RaidLevel] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithThrowType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var `throw`: POGOProtos_Data_Quests_QuestCondition.WithThrowType.OneOf_Throw? = nil

    public var throwType: POGOProtos_Enums_ActivityType {
      get {
        if case .throwType(let v)? = `throw` {return v}
        return .activityUnknown
      }
      set {`throw` = .throwType(newValue)}
    }

    public var hit: Bool {
      get {
        if case .hit(let v)? = `throw` {return v}
        return false
      }
      set {`throw` = .hit(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Throw: Equatable {
      case throwType(POGOProtos_Enums_ActivityType)
      case hit(Bool)

    #if !swift(>=4.1)
      public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithThrowType.OneOf_Throw, rhs: POGOProtos_Data_Quests_QuestCondition.WithThrowType.OneOf_Throw) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.throwType, .throwType): return {
          guard case .throwType(let l) = lhs, case .throwType(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.hit, .hit): return {
          guard case .hit(let l) = lhs, case .hit(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public init() {}
  }

  public struct WithCurveBall {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithWinGymBattleStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithSuperEffectiveChargeMove {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithItem {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var item: POGOProtos_Inventory_Item_ItemId = .itemUnknown

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithUniquePokestop {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithQuestContext {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var context: POGOProtos_Data_Quests_QuestCondition.WithQuestContext.Context = .unset

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Context: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unset // = 0
      case storyQuest // = 1
      case challengeQuest // = 2
      case UNRECOGNIZED(Int)

      public init() {
        self = .unset
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .storyQuest
        case 2: self = .challengeQuest
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unset: return 0
        case .storyQuest: return 1
        case .challengeQuest: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct WithBadgeType {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var badgeType: [POGOProtos_Enums_BadgeType] = []

    public var badgeRank: Int32 = 0

    public var amount: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithPlayerLevel {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var level: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct WithWinBattleStatus {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension POGOProtos_Data_Quests_QuestCondition.ConditionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Quests_QuestCondition.ConditionType] = [
    .unset,
    .withPokemonType,
    .withPokemonCategory,
    .withWeatherBoost,
    .withDailyCaptureBonus,
    .withDailySpinBonus,
    .withWinRaidStatus,
    .withRaidLevel,
    .withThrowType,
    .withWinGymBattleStatus,
    .withSuperEffectiveCharge,
    .withItem,
    .withUniquePokestop,
    .withQuestContext,
    .withThrowTypeInARow,
    .withCurveBall,
    .withBadgeType,
    .withPlayerLevel,
    .withWinBattleStatus,
    .withNewFriend,
    .withDaysInARow,
    .withUniquePokemon,
    .withNpcCombat,
    .withPvpCombat,
    .withLocation,
    .withDistance,
    .withPokemonAlignment,
    .withInvasionCharacter,
    .withBuddy,
    .withBuddyInterestingPoi,
    .withDailyBuddyAffection,
    .withPokemonLevel,
    .withSingleDay,
    .withUniquePokemonTeam,
    .withMaxCp,
    .withLuckyPokemon,
    .withLegendaryPokemon,
    .withTempEvoPokemon,
    .withGblRank,
    .withCatchesInARow,
    .withEncounterType,
    .withCombatType,
  ]
}

extension POGOProtos_Data_Quests_QuestCondition.WithQuestContext.Context: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Quests_QuestCondition.WithQuestContext.Context] = [
    .unset,
    .storyQuest,
    .challengeQuest,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "POGOProtos.Data.Quests"

extension POGOProtos_Data_Quests_QuestCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QuestCondition"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "with_pokemon_type"),
    3: .standard(proto: "with_pokemon_category"),
    4: .standard(proto: "with_weather_boost"),
    5: .standard(proto: "with_daily_capture_bonus"),
    6: .standard(proto: "with_daily_spin_bonus"),
    7: .standard(proto: "with_win_raid_status"),
    8: .standard(proto: "with_raid_level"),
    9: .standard(proto: "with_throw_type"),
    10: .standard(proto: "with_win_gym_battle_status"),
    11: .standard(proto: "with_super_effective_charge_move"),
    12: .standard(proto: "with_item"),
    13: .standard(proto: "with_unique_pokestop"),
    14: .standard(proto: "with_quest_context"),
    15: .standard(proto: "with_badge_type"),
    16: .standard(proto: "with_player_level"),
    17: .standard(proto: "with_win_battle_status"),
    18: .standard(proto: "with_unique_pokemon"),
    19: .standard(proto: "with_npc_combat"),
    20: .standard(proto: "with_pvp_combat"),
    21: .standard(proto: "with_location"),
    22: .standard(proto: "with_distance"),
    23: .standard(proto: "with_invasion_character"),
    24: .standard(proto: "with_pokemon_alignment"),
    25: .standard(proto: "with_buddy"),
    26: .standard(proto: "with_daily_buddy_affection"),
    27: .standard(proto: "with_pokemon_level"),
    28: .standard(proto: "with_max_cp"),
    29: .standard(proto: "with_temp_evo_id"),
    30: .standard(proto: "with_gbl_rank"),
    31: .standard(proto: "with_encounter_type"),
    32: .standard(proto: "with_combat_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithPokemonType?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withPokemonType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withPokemonType(v)}
      }()
      case 3: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withPokemonCategory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withPokemonCategory(v)}
      }()
      case 4: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withWeatherBoost(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withWeatherBoost(v)}
      }()
      case 5: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withDailyCaptureBonus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withDailyCaptureBonus(v)}
      }()
      case 6: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withDailySpinBonus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withDailySpinBonus(v)}
      }()
      case 7: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withWinRaidStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withWinRaidStatus(v)}
      }()
      case 8: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithRaidLevel?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withRaidLevel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withRaidLevel(v)}
      }()
      case 9: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithThrowType?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withThrowType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withThrowType(v)}
      }()
      case 10: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withWinGymBattleStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withWinGymBattleStatus(v)}
      }()
      case 11: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withSuperEffectiveChargeMove(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withSuperEffectiveChargeMove(v)}
      }()
      case 12: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithItem?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withItem(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withItem(v)}
      }()
      case 13: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withUniquePokestop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withUniquePokestop(v)}
      }()
      case 14: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithQuestContext?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withQuestContext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withQuestContext(v)}
      }()
      case 15: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithBadgeType?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withBadgeType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withBadgeType(v)}
      }()
      case 16: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withPlayerLevel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withPlayerLevel(v)}
      }()
      case 17: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withWinBattleStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withWinBattleStatus(v)}
      }()
      case 18: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withUniquePokemon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withUniquePokemon(v)}
      }()
      case 19: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithNpcCombat?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withNpcCombat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withNpcCombat(v)}
      }()
      case 20: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithPvpCombat?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withPvpCombat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withPvpCombat(v)}
      }()
      case 21: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithLocation?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withLocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withLocation(v)}
      }()
      case 22: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithDistance?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withDistance(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withDistance(v)}
      }()
      case 23: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withInvasionCharacter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withInvasionCharacter(v)}
      }()
      case 24: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withPokemonAlignment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withPokemonAlignment(v)}
      }()
      case 25: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithBuddy?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withBuddy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withBuddy(v)}
      }()
      case 26: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withDailyBuddyAffection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withDailyBuddyAffection(v)}
      }()
      case 27: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withPokemonLevel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withPokemonLevel(v)}
      }()
      case 28: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithMaxCp?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withMaxCp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withMaxCp(v)}
      }()
      case 29: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithTempEvoId?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withTempEvoID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withTempEvoID(v)}
      }()
      case 30: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithGblRank?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withGblRank(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withGblRank(v)}
      }()
      case 31: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithEncounterType?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withEncounterType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withEncounterType(v)}
      }()
      case 32: try {
        var v: POGOProtos_Data_Quests_QuestCondition.WithCombatType?
        if let current = self.condition {
          try decoder.handleConflictingOneOf()
          if case .withCombatType(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.condition = .withCombatType(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unset {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.condition {
    case .withPokemonType?: try {
      guard case .withPokemonType(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .withPokemonCategory?: try {
      guard case .withPokemonCategory(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .withWeatherBoost?: try {
      guard case .withWeatherBoost(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .withDailyCaptureBonus?: try {
      guard case .withDailyCaptureBonus(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .withDailySpinBonus?: try {
      guard case .withDailySpinBonus(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .withWinRaidStatus?: try {
      guard case .withWinRaidStatus(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .withRaidLevel?: try {
      guard case .withRaidLevel(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .withThrowType?: try {
      guard case .withThrowType(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .withWinGymBattleStatus?: try {
      guard case .withWinGymBattleStatus(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .withSuperEffectiveChargeMove?: try {
      guard case .withSuperEffectiveChargeMove(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .withItem?: try {
      guard case .withItem(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .withUniquePokestop?: try {
      guard case .withUniquePokestop(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .withQuestContext?: try {
      guard case .withQuestContext(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .withBadgeType?: try {
      guard case .withBadgeType(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .withPlayerLevel?: try {
      guard case .withPlayerLevel(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .withWinBattleStatus?: try {
      guard case .withWinBattleStatus(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .withUniquePokemon?: try {
      guard case .withUniquePokemon(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .withNpcCombat?: try {
      guard case .withNpcCombat(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .withPvpCombat?: try {
      guard case .withPvpCombat(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .withLocation?: try {
      guard case .withLocation(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .withDistance?: try {
      guard case .withDistance(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case .withInvasionCharacter?: try {
      guard case .withInvasionCharacter(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    }()
    case .withPokemonAlignment?: try {
      guard case .withPokemonAlignment(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
    }()
    case .withBuddy?: try {
      guard case .withBuddy(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
    }()
    case .withDailyBuddyAffection?: try {
      guard case .withDailyBuddyAffection(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
    }()
    case .withPokemonLevel?: try {
      guard case .withPokemonLevel(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
    }()
    case .withMaxCp?: try {
      guard case .withMaxCp(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
    }()
    case .withTempEvoID?: try {
      guard case .withTempEvoID(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
    }()
    case .withGblRank?: try {
      guard case .withGblRank(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
    }()
    case .withEncounterType?: try {
      guard case .withEncounterType(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
    }()
    case .withCombatType?: try {
      guard case .withCombatType(let v)? = self.condition else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition, rhs: POGOProtos_Data_Quests_QuestCondition) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.condition != rhs.condition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.ConditionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "WITH_POKEMON_TYPE"),
    2: .same(proto: "WITH_POKEMON_CATEGORY"),
    3: .same(proto: "WITH_WEATHER_BOOST"),
    4: .same(proto: "WITH_DAILY_CAPTURE_BONUS"),
    5: .same(proto: "WITH_DAILY_SPIN_BONUS"),
    6: .same(proto: "WITH_WIN_RAID_STATUS"),
    7: .same(proto: "WITH_RAID_LEVEL"),
    8: .same(proto: "WITH_THROW_TYPE"),
    9: .same(proto: "WITH_WIN_GYM_BATTLE_STATUS"),
    10: .same(proto: "WITH_SUPER_EFFECTIVE_CHARGE"),
    11: .same(proto: "WITH_ITEM"),
    12: .same(proto: "WITH_UNIQUE_POKESTOP"),
    13: .same(proto: "WITH_QUEST_CONTEXT"),
    14: .same(proto: "WITH_THROW_TYPE_IN_A_ROW"),
    15: .same(proto: "WITH_CURVE_BALL"),
    16: .same(proto: "WITH_BADGE_TYPE"),
    17: .same(proto: "WITH_PLAYER_LEVEL"),
    18: .same(proto: "WITH_WIN_BATTLE_STATUS"),
    19: .same(proto: "WITH_NEW_FRIEND"),
    20: .same(proto: "WITH_DAYS_IN_A_ROW"),
    21: .same(proto: "WITH_UNIQUE_POKEMON"),
    22: .same(proto: "WITH_NPC_COMBAT"),
    23: .same(proto: "WITH_PVP_COMBAT"),
    24: .same(proto: "WITH_LOCATION"),
    25: .same(proto: "WITH_DISTANCE"),
    26: .same(proto: "WITH_POKEMON_ALIGNMENT"),
    27: .same(proto: "WITH_INVASION_CHARACTER"),
    28: .same(proto: "WITH_BUDDY"),
    29: .same(proto: "WITH_BUDDY_INTERESTING_POI"),
    30: .same(proto: "WITH_DAILY_BUDDY_AFFECTION"),
    31: .same(proto: "WITH_POKEMON_LEVEL"),
    32: .same(proto: "WITH_SINGLE_DAY"),
    33: .same(proto: "WITH_UNIQUE_POKEMON_TEAM"),
    34: .same(proto: "WITH_MAX_CP"),
    35: .same(proto: "WITH_LUCKY_POKEMON"),
    36: .same(proto: "WITH_LEGENDARY_POKEMON"),
    37: .same(proto: "WITH_TEMP_EVO_POKEMON"),
    38: .same(proto: "WITH_GBL_RANK"),
    39: .same(proto: "WITH_CATCHES_IN_A_ROW"),
    40: .same(proto: "WITH_ENCOUNTER_TYPE"),
    41: .same(proto: "WITH_COMBAT_TYPE"),
  ]
}

extension POGOProtos_Data_Quests_QuestCondition.WithCombatType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithCombatType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "combat_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.combatType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.combatType.isEmpty {
      try visitor.visitPackedEnumField(value: self.combatType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithCombatType, rhs: POGOProtos_Data_Quests_QuestCondition.WithCombatType) -> Bool {
    if lhs.combatType != rhs.combatType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithEncounterType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithEncounterType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encounter_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.encounterType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encounterType.isEmpty {
      try visitor.visitPackedEnumField(value: self.encounterType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithEncounterType, rhs: POGOProtos_Data_Quests_QuestCondition.WithEncounterType) -> Bool {
    if lhs.encounterType != rhs.encounterType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithGblRank: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithGblRank"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rank"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.rank) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rank != 0 {
      try visitor.visitSingularInt32Field(value: self.rank, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithGblRank, rhs: POGOProtos_Data_Quests_QuestCondition.WithGblRank) -> Bool {
    if lhs.rank != rhs.rank {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithTempEvoId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithTempEvoId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "mega_form"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.megaForm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.megaForm.isEmpty {
      try visitor.visitPackedEnumField(value: self.megaForm, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithTempEvoId, rhs: POGOProtos_Data_Quests_QuestCondition.WithTempEvoId) -> Bool {
    if lhs.megaForm != rhs.megaForm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithMaxCp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithMaxCp"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_cp"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxCp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxCp != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCp, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithMaxCp, rhs: POGOProtos_Data_Quests_QuestCondition.WithMaxCp) -> Bool {
    if lhs.maxCp != rhs.maxCp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithPokemonLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.maxLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxLevel != false {
      try visitor.visitSingularBoolField(value: self.maxLevel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel, rhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonLevel) -> Bool {
    if lhs.maxLevel != rhs.maxLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithDailyBuddyAffection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_buddy_affection_earned_today"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minBuddyAffectionEarnedToday) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minBuddyAffectionEarnedToday != 0 {
      try visitor.visitSingularInt32Field(value: self.minBuddyAffectionEarnedToday, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection, rhs: POGOProtos_Data_Quests_QuestCondition.WithDailyBuddyAffection) -> Bool {
    if lhs.minBuddyAffectionEarnedToday != rhs.minBuddyAffectionEarnedToday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithBuddy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithBuddy"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_buddy_level"),
    2: .standard(proto: "must_be_on_map"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.minBuddyLevel) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.mustBeOnMap) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minBuddyLevel != .unset {
      try visitor.visitSingularEnumField(value: self.minBuddyLevel, fieldNumber: 1)
    }
    if self.mustBeOnMap != false {
      try visitor.visitSingularBoolField(value: self.mustBeOnMap, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithBuddy, rhs: POGOProtos_Data_Quests_QuestCondition.WithBuddy) -> Bool {
    if lhs.minBuddyLevel != rhs.minBuddyLevel {return false}
    if lhs.mustBeOnMap != rhs.mustBeOnMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithPokemonAlignment"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "alignment"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.alignment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alignment.isEmpty {
      try visitor.visitPackedEnumField(value: self.alignment, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment, rhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonAlignment) -> Bool {
    if lhs.alignment != rhs.alignment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithInvasionCharacter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "category"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.category) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.category.isEmpty {
      try visitor.visitPackedEnumField(value: self.category, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter, rhs: POGOProtos_Data_Quests_QuestCondition.WithInvasionCharacter) -> Bool {
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithUniquePokemon"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon, rhs: POGOProtos_Data_Quests_QuestCondition.WithUniquePokemon) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithPvpCombat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithPvpCombat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requires_win"),
    2: .standard(proto: "combat_league_template_id"),
    3: .standard(proto: "combat_league_badge"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.requiresWin) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.combatLeagueTemplateID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.combatLeagueBadge) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requiresWin != false {
      try visitor.visitSingularBoolField(value: self.requiresWin, fieldNumber: 1)
    }
    if !self.combatLeagueTemplateID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.combatLeagueTemplateID, fieldNumber: 2)
    }
    if self.combatLeagueBadge != .badgeUnset {
      try visitor.visitSingularEnumField(value: self.combatLeagueBadge, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithPvpCombat, rhs: POGOProtos_Data_Quests_QuestCondition.WithPvpCombat) -> Bool {
    if lhs.requiresWin != rhs.requiresWin {return false}
    if lhs.combatLeagueTemplateID != rhs.combatLeagueTemplateID {return false}
    if lhs.combatLeagueBadge != rhs.combatLeagueBadge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithNpcCombat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithNpcCombat"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "requires_win"),
    2: .standard(proto: "combat_npc_trainer_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.requiresWin) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.combatNpcTrainerID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requiresWin != false {
      try visitor.visitSingularBoolField(value: self.requiresWin, fieldNumber: 1)
    }
    if !self.combatNpcTrainerID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.combatNpcTrainerID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithNpcCombat, rhs: POGOProtos_Data_Quests_QuestCondition.WithNpcCombat) -> Bool {
    if lhs.requiresWin != rhs.requiresWin {return false}
    if lhs.combatNpcTrainerID != rhs.combatNpcTrainerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithLocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithLocation"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "s2_cell_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.s2CellID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.s2CellID.isEmpty {
      try visitor.visitPackedInt64Field(value: self.s2CellID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithLocation, rhs: POGOProtos_Data_Quests_QuestCondition.WithLocation) -> Bool {
    if lhs.s2CellID != rhs.s2CellID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithDistance: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithDistance"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distance_km"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.distanceKm) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distanceKm != 0 {
      try visitor.visitSingularDoubleField(value: self.distanceKm, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithDistance, rhs: POGOProtos_Data_Quests_QuestCondition.WithDistance) -> Bool {
    if lhs.distanceKm != rhs.distanceKm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithPokemonType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithPokemonType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pokemon_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.pokemonType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pokemonType.isEmpty {
      try visitor.visitPackedEnumField(value: self.pokemonType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonType, rhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonType) -> Bool {
    if lhs.pokemonType != rhs.pokemonType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithWeatherBoost"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost, rhs: POGOProtos_Data_Quests_QuestCondition.WithWeatherBoost) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithPokemonCategory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "category_name"),
    2: .standard(proto: "pokemon_ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.categoryName) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.pokemonIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.categoryName.isEmpty {
      try visitor.visitSingularStringField(value: self.categoryName, fieldNumber: 1)
    }
    if !self.pokemonIds.isEmpty {
      try visitor.visitPackedEnumField(value: self.pokemonIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory, rhs: POGOProtos_Data_Quests_QuestCondition.WithPokemonCategory) -> Bool {
    if lhs.categoryName != rhs.categoryName {return false}
    if lhs.pokemonIds != rhs.pokemonIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithDailyCaptureBonus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus, rhs: POGOProtos_Data_Quests_QuestCondition.WithDailyCaptureBonus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithDailySpinBonus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus, rhs: POGOProtos_Data_Quests_QuestCondition.WithDailySpinBonus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithWinRaidStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus, rhs: POGOProtos_Data_Quests_QuestCondition.WithWinRaidStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithRaidLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithRaidLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raid_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.raidLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.raidLevel.isEmpty {
      try visitor.visitPackedEnumField(value: self.raidLevel, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithRaidLevel, rhs: POGOProtos_Data_Quests_QuestCondition.WithRaidLevel) -> Bool {
    if lhs.raidLevel != rhs.raidLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithThrowType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithThrowType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "throw_type"),
    2: .same(proto: "hit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.`throw` != nil {try decoder.handleConflictingOneOf()}
        var v: POGOProtos_Enums_ActivityType?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {self.`throw` = .throwType(v)}
      }()
      case 2: try {
        if self.`throw` != nil {try decoder.handleConflictingOneOf()}
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {self.`throw` = .hit(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.`throw` {
    case .throwType?: try {
      guard case .throwType(let v)? = self.`throw` else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }()
    case .hit?: try {
      guard case .hit(let v)? = self.`throw` else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithThrowType, rhs: POGOProtos_Data_Quests_QuestCondition.WithThrowType) -> Bool {
    if lhs.`throw` != rhs.`throw` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithCurveBall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithCurveBall"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithCurveBall, rhs: POGOProtos_Data_Quests_QuestCondition.WithCurveBall) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithWinGymBattleStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus, rhs: POGOProtos_Data_Quests_QuestCondition.WithWinGymBattleStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithSuperEffectiveChargeMove"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove, rhs: POGOProtos_Data_Quests_QuestCondition.WithSuperEffectiveChargeMove) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithItem: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithItem"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "item"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.item) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.item != .itemUnknown {
      try visitor.visitSingularEnumField(value: self.item, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithItem, rhs: POGOProtos_Data_Quests_QuestCondition.WithItem) -> Bool {
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithUniquePokestop"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop, rhs: POGOProtos_Data_Quests_QuestCondition.WithUniquePokestop) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithQuestContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithQuestContext"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "context"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.context) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.context != .unset {
      try visitor.visitSingularEnumField(value: self.context, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithQuestContext, rhs: POGOProtos_Data_Quests_QuestCondition.WithQuestContext) -> Bool {
    if lhs.context != rhs.context {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithQuestContext.Context: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "STORY_QUEST"),
    2: .same(proto: "CHALLENGE_QUEST"),
  ]
}

extension POGOProtos_Data_Quests_QuestCondition.WithBadgeType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithBadgeType"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "badge_type"),
    2: .standard(proto: "badge_rank"),
    3: .same(proto: "amount"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.badgeType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.badgeRank) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.amount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.badgeType.isEmpty {
      try visitor.visitPackedEnumField(value: self.badgeType, fieldNumber: 1)
    }
    if self.badgeRank != 0 {
      try visitor.visitSingularInt32Field(value: self.badgeRank, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt32Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithBadgeType, rhs: POGOProtos_Data_Quests_QuestCondition.WithBadgeType) -> Bool {
    if lhs.badgeType != rhs.badgeType {return false}
    if lhs.badgeRank != rhs.badgeRank {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithPlayerLevel"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.level) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.level != 0 {
      try visitor.visitSingularInt32Field(value: self.level, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel, rhs: POGOProtos_Data_Quests_QuestCondition.WithPlayerLevel) -> Bool {
    if lhs.level != rhs.level {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Quests_QuestCondition.protoMessageName + ".WithWinBattleStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus, rhs: POGOProtos_Data_Quests_QuestCondition.WithWinBattleStatus) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
