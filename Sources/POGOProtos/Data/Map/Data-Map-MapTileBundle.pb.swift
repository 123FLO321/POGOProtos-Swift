// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: POGOProtos/Data/Map/MapTileBundle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct POGOProtos_Data_Map_MapTileBundle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mapTile: [POGOProtos_Data_Map_MapTileBundle.MapTileData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MapTileData {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var mapTile: POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile {
      get {return _mapTile ?? POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile()}
      set {_mapTile = newValue}
    }
    /// Returns true if `mapTile` has been explicitly set.
    public var hasMapTile: Bool {return self._mapTile != nil}
    /// Clears the value of `mapTile`. Subsequent reads from it will return its default value.
    public mutating func clearMapTile() {self._mapTile = nil}

    public var tileData: POGOProtos_Data_Map_MapCompositionRoot {
      get {return _tileData ?? POGOProtos_Data_Map_MapCompositionRoot()}
      set {_tileData = newValue}
    }
    /// Returns true if `tileData` has been explicitly set.
    public var hasTileData: Bool {return self._tileData != nil}
    /// Clears the value of `tileData`. Subsequent reads from it will return its default value.
    public mutating func clearTileData() {self._tileData = nil}

    public var labelData: POGOProtos_Data_Map_LabelTile {
      get {return _labelData ?? POGOProtos_Data_Map_LabelTile()}
      set {_labelData = newValue}
    }
    /// Returns true if `labelData` has been explicitly set.
    public var hasLabelData: Bool {return self._labelData != nil}
    /// Clears the value of `labelData`. Subsequent reads from it will return its default value.
    public mutating func clearLabelData() {self._labelData = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct MapTile {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var tileVariant: UInt32 = 0

      public var tileIndexX: Int32 = 0

      public var tileIndexY: Int32 = 0

      public var zoomLevel: Int32 = 0

      public var indoorLevelID: String = String()

      public var pertileEpoch: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum TextSizeEnum: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unset // = 0
        case small // = 1
        case medium // = 2
        case large // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .unset
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unset
          case 1: self = .small
          case 2: self = .medium
          case 3: self = .large
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unset: return 0
          case .small: return 1
          case .medium: return 2
          case .large: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum TileTypeEnum: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case unset // = 0
        case mapAtlas // = 2
        case satellite // = 3
        case traffic // = 4
        case gifAtlas // = 5
        case hybrid // = 6
        case terrain // = 7
        case clickableLayer // = 8
        case streetView // = 9
        case vectorAtlas // = 10
        case roadGraph // = 11
        case terrainNoLabels // = 12
        case vectorTransit // = 13
        case indoor // = 14
        case labelsOnly // = 15
        case personalizedSmartmaps // = 16
        case UNRECOGNIZED(Int)

        public init() {
          self = .unset
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .unset
          case 2: self = .mapAtlas
          case 3: self = .satellite
          case 4: self = .traffic
          case 5: self = .gifAtlas
          case 6: self = .hybrid
          case 7: self = .terrain
          case 8: self = .clickableLayer
          case 9: self = .streetView
          case 10: self = .vectorAtlas
          case 11: self = .roadGraph
          case 12: self = .terrainNoLabels
          case 13: self = .vectorTransit
          case 14: self = .indoor
          case 15: self = .labelsOnly
          case 16: self = .personalizedSmartmaps
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .unset: return 0
          case .mapAtlas: return 2
          case .satellite: return 3
          case .traffic: return 4
          case .gifAtlas: return 5
          case .hybrid: return 6
          case .terrain: return 7
          case .clickableLayer: return 8
          case .streetView: return 9
          case .vectorAtlas: return 10
          case .roadGraph: return 11
          case .terrainNoLabels: return 12
          case .vectorTransit: return 13
          case .indoor: return 14
          case .labelsOnly: return 15
          case .personalizedSmartmaps: return 16
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public init() {}
    }

    public init() {}

    fileprivate var _mapTile: POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile? = nil
    fileprivate var _tileData: POGOProtos_Data_Map_MapCompositionRoot? = nil
    fileprivate var _labelData: POGOProtos_Data_Map_LabelTile? = nil
  }

  public init() {}
}

#if swift(>=4.2)

extension POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile.TextSizeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile.TextSizeEnum] = [
    .unset,
    .small,
    .medium,
    .large,
  ]
}

extension POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile.TileTypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile.TileTypeEnum] = [
    .unset,
    .mapAtlas,
    .satellite,
    .traffic,
    .gifAtlas,
    .hybrid,
    .terrain,
    .clickableLayer,
    .streetView,
    .vectorAtlas,
    .roadGraph,
    .terrainNoLabels,
    .vectorTransit,
    .indoor,
    .labelsOnly,
    .personalizedSmartmaps,
  ]
}

#endif  // swift(>=4.2)

public struct POGOProtos_Data_Map_MapCompositionRoot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mapArea: [POGOProtos_Data_Map_MapCompositionRoot.MapArea] = []

  public var mapProvider: [POGOProtos_Data_Map_MapCompositionRoot.MapProvider] = []

  public var namedMapSettings: [POGOProtos_Data_Map_MapCompositionRoot.NamedMapSettings] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MapArea {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var description_p: String = String()

    public var epoch: Int32 = 0

    public var mapProvider: String = String()

    public var boundingRect: [POGOProtos_Data_Map_MapCompositionRoot.MapArea.BoundingRect] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct BoundingRect {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var north: Double = 0

      public var south: Double = 0

      public var east: Double = 0

      public var west: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct MapProvider {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var baseURL: String = String()

    public var queryFormat: String = String()

    public var mapType: POGOProtos_Data_Map_MapCompositionRoot.MapProvider.MapType = .unset

    public var hideAttribution: Bool = false

    public var minTileLevel: Int32 = 0

    public var maxTileLevel: Int32 = 0

    public var bundleZoomRange: [POGOProtos_Data_Map_MapCompositionRoot.MapProvider.BundleZoomRange] = []

    public var settings: POGOProtos_Data_Map_MapCompositionRoot.MapProvider.OneOf_Settings? = nil

    public var gmmSettings: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings {
      get {
        if case .gmmSettings(let v)? = settings {return v}
        return POGOProtos_Data_Map_MapCompositionRoot.GmmSettings()
      }
      set {settings = .gmmSettings(newValue)}
    }

    public var settingsName: String {
      get {
        if case .settingsName(let v)? = settings {return v}
        return String()
      }
      set {settings = .settingsName(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Settings: Equatable {
      case gmmSettings(POGOProtos_Data_Map_MapCompositionRoot.GmmSettings)
      case settingsName(String)

    #if !swift(>=4.1)
      public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.MapProvider.OneOf_Settings, rhs: POGOProtos_Data_Map_MapCompositionRoot.MapProvider.OneOf_Settings) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.gmmSettings, .gmmSettings): return {
          guard case .gmmSettings(let l) = lhs, case .gmmSettings(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.settingsName, .settingsName): return {
          guard case .settingsName(let l) = lhs, case .settingsName(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    public enum MapType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case unset // = 0
      case gmm // = 1
      case osm // = 2
      case blank // = 3
      case gmmBundle // = 4
      case UNRECOGNIZED(Int)

      public init() {
        self = .unset
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unset
        case 1: self = .gmm
        case 2: self = .osm
        case 3: self = .blank
        case 4: self = .gmmBundle
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unset: return 0
        case .gmm: return 1
        case .osm: return 2
        case .blank: return 3
        case .gmmBundle: return 4
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public struct BundleZoomRange {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var minZoom: Int32 = 0

      public var maxZoom: Int32 = 0

      public var requestZoomOffset: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public struct NamedMapSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var name: String = String()

    public var gmmSettings: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings {
      get {return _gmmSettings ?? POGOProtos_Data_Map_MapCompositionRoot.GmmSettings()}
      set {_gmmSettings = newValue}
    }
    /// Returns true if `gmmSettings` has been explicitly set.
    public var hasGmmSettings: Bool {return self._gmmSettings != nil}
    /// Clears the value of `gmmSettings`. Subsequent reads from it will return its default value.
    public mutating func clearGmmSettings() {self._gmmSettings = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _gmmSettings: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings? = nil
  }

  public struct GmmSettings {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var layerRules: [POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct LayerRule {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var fillColors: [POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.MaskedColor] = []

      public var roadPriority: [POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmRoadPriority] = []

      public var roadAttributeBitfield: UInt32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum GmmLayerType: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case area // = 0
        case road // = 1
        case building // = 2
        case lineMesh // = 3
        case UNRECOGNIZED(Int)

        public init() {
          self = .area
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .area
          case 1: self = .road
          case 2: self = .building
          case 3: self = .lineMesh
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .area: return 0
          case .road: return 1
          case .building: return 2
          case .lineMesh: return 3
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public enum GmmRoadPriority: SwiftProtobuf.Enum {
        public typealias RawValue = Int
        case priorityNone // = 0
        case priorityTerminal // = 1
        case priorityLocal // = 2
        case priorityMinorArterial // = 3
        case priorityMajorArterial // = 4
        case prioritySecondaryRoad // = 5
        case priorityPrimaryHighway // = 6
        case priorityLimitedAccess // = 7
        case priorityControlledAccess // = 8
        case priorityNonTraffic // = 9
        case UNRECOGNIZED(Int)

        public init() {
          self = .priorityNone
        }

        public init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .priorityNone
          case 1: self = .priorityTerminal
          case 2: self = .priorityLocal
          case 3: self = .priorityMinorArterial
          case 4: self = .priorityMajorArterial
          case 5: self = .prioritySecondaryRoad
          case 6: self = .priorityPrimaryHighway
          case 7: self = .priorityLimitedAccess
          case 8: self = .priorityControlledAccess
          case 9: self = .priorityNonTraffic
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        public var rawValue: Int {
          switch self {
          case .priorityNone: return 0
          case .priorityTerminal: return 1
          case .priorityLocal: return 2
          case .priorityMinorArterial: return 3
          case .priorityMajorArterial: return 4
          case .prioritySecondaryRoad: return 5
          case .priorityPrimaryHighway: return 6
          case .priorityLimitedAccess: return 7
          case .priorityControlledAccess: return 8
          case .priorityNonTraffic: return 9
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      public struct MaskedColor {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var colorArgb: UInt32 = 0

        public var colorMaskArgb: UInt32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension POGOProtos_Data_Map_MapCompositionRoot.MapProvider.MapType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Map_MapCompositionRoot.MapProvider.MapType] = [
    .unset,
    .gmm,
    .osm,
    .blank,
    .gmmBundle,
  ]
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmLayerType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmLayerType] = [
    .area,
    .road,
    .building,
    .lineMesh,
  ]
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmRoadPriority: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmRoadPriority] = [
    .priorityNone,
    .priorityTerminal,
    .priorityLocal,
    .priorityMinorArterial,
    .priorityMajorArterial,
    .prioritySecondaryRoad,
    .priorityPrimaryHighway,
    .priorityLimitedAccess,
    .priorityControlledAccess,
    .priorityNonTraffic,
  ]
}

#endif  // swift(>=4.2)

public struct POGOProtos_Data_Map_LabelTile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var labels: [POGOProtos_Data_Map_LabelTile.Label] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Label {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var priority: Int32 = 0

    public var geometry: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry {
      get {return _geometry ?? POGOProtos_Data_Map_LabelTile.Label.LabelGeometry()}
      set {_geometry = newValue}
    }
    /// Returns true if `geometry` has been explicitly set.
    public var hasGeometry: Bool {return self._geometry != nil}
    /// Clears the value of `geometry`. Subsequent reads from it will return its default value.
    public mutating func clearGeometry() {self._geometry = nil}

    public var content: POGOProtos_Data_Map_LabelTile.Label.LabelContent {
      get {return _content ?? POGOProtos_Data_Map_LabelTile.Label.LabelContent()}
      set {_content = newValue}
    }
    /// Returns true if `content` has been explicitly set.
    public var hasContent: Bool {return self._content != nil}
    /// Clears the value of `content`. Subsequent reads from it will return its default value.
    public mutating func clearContent() {self._content = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct LabelGeometry {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var point: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.PixelPoint {
        get {return _point ?? POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.PixelPoint()}
        set {_point = newValue}
      }
      /// Returns true if `point` has been explicitly set.
      public var hasPoint: Bool {return self._point != nil}
      /// Clears the value of `point`. Subsequent reads from it will return its default value.
      public mutating func clearPoint() {self._point = nil}

      public var minZoom: Int32 = 0

      public var maxZoom: Int32 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct PixelPoint {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var pixelX: Int32 = 0

        public var pixelY: Int32 = 0

        public var zoomLevel: Int32 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _point: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.PixelPoint? = nil
    }

    public struct LabelContent {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var localizations: [POGOProtos_Data_Map_LabelTile.Label.LabelContent.LabelContentLocalization] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct LabelContentLocalization {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var language: String = String()

        public var name: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public init() {}

    fileprivate var _geometry: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry? = nil
    fileprivate var _content: POGOProtos_Data_Map_LabelTile.Label.LabelContent? = nil
  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "POGOProtos.Data.Map"

extension POGOProtos_Data_Map_MapTileBundle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MapTileBundle"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_tile"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mapTile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mapTile.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapTile, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapTileBundle, rhs: POGOProtos_Data_Map_MapTileBundle) -> Bool {
    if lhs.mapTile != rhs.mapTile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapTileBundle.MapTileData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapTileBundle.protoMessageName + ".MapTileData"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_tile"),
    2: .standard(proto: "tile_data"),
    3: .standard(proto: "label_data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mapTile) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tileData) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._labelData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._mapTile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._tileData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._labelData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapTileBundle.MapTileData, rhs: POGOProtos_Data_Map_MapTileBundle.MapTileData) -> Bool {
    if lhs._mapTile != rhs._mapTile {return false}
    if lhs._tileData != rhs._tileData {return false}
    if lhs._labelData != rhs._labelData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapTileBundle.MapTileData.protoMessageName + ".MapTile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tile_variant"),
    2: .standard(proto: "tile_index_x"),
    3: .standard(proto: "tile_index_y"),
    4: .standard(proto: "zoom_level"),
    5: .standard(proto: "indoor_level_id"),
    6: .standard(proto: "pertile_epoch"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.tileVariant) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.tileIndexX) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.tileIndexY) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.zoomLevel) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.indoorLevelID) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.pertileEpoch) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.tileVariant != 0 {
      try visitor.visitSingularUInt32Field(value: self.tileVariant, fieldNumber: 1)
    }
    if self.tileIndexX != 0 {
      try visitor.visitSingularInt32Field(value: self.tileIndexX, fieldNumber: 2)
    }
    if self.tileIndexY != 0 {
      try visitor.visitSingularInt32Field(value: self.tileIndexY, fieldNumber: 3)
    }
    if self.zoomLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.zoomLevel, fieldNumber: 4)
    }
    if !self.indoorLevelID.isEmpty {
      try visitor.visitSingularStringField(value: self.indoorLevelID, fieldNumber: 5)
    }
    if self.pertileEpoch != 0 {
      try visitor.visitSingularInt32Field(value: self.pertileEpoch, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile, rhs: POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile) -> Bool {
    if lhs.tileVariant != rhs.tileVariant {return false}
    if lhs.tileIndexX != rhs.tileIndexX {return false}
    if lhs.tileIndexY != rhs.tileIndexY {return false}
    if lhs.zoomLevel != rhs.zoomLevel {return false}
    if lhs.indoorLevelID != rhs.indoorLevelID {return false}
    if lhs.pertileEpoch != rhs.pertileEpoch {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile.TextSizeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_SIZE_ENUM_UNSET"),
    1: .same(proto: "SMALL"),
    2: .same(proto: "MEDIUM"),
    3: .same(proto: "LARGE"),
  ]
}

extension POGOProtos_Data_Map_MapTileBundle.MapTileData.MapTile.TileTypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TILE_TYPE_ENUM_UNSET"),
    2: .same(proto: "MAP_ATLAS"),
    3: .same(proto: "SATELLITE"),
    4: .same(proto: "TRAFFIC"),
    5: .same(proto: "GIF_ATLAS"),
    6: .same(proto: "HYBRID"),
    7: .same(proto: "TERRAIN"),
    8: .same(proto: "CLICKABLE_LAYER"),
    9: .same(proto: "STREET_VIEW"),
    10: .same(proto: "VECTOR_ATLAS"),
    11: .same(proto: "ROAD_GRAPH"),
    12: .same(proto: "TERRAIN_NO_LABELS"),
    13: .same(proto: "VECTOR_TRANSIT"),
    14: .same(proto: "INDOOR"),
    15: .same(proto: "LABELS_ONLY"),
    16: .same(proto: "PERSONALIZED_SMARTMAPS"),
  ]
}

extension POGOProtos_Data_Map_MapCompositionRoot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MapCompositionRoot"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "map_area"),
    2: .standard(proto: "map_provider"),
    3: .standard(proto: "named_map_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.mapArea) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.mapProvider) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.namedMapSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mapArea.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapArea, fieldNumber: 1)
    }
    if !self.mapProvider.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.mapProvider, fieldNumber: 2)
    }
    if !self.namedMapSettings.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namedMapSettings, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot, rhs: POGOProtos_Data_Map_MapCompositionRoot) -> Bool {
    if lhs.mapArea != rhs.mapArea {return false}
    if lhs.mapProvider != rhs.mapProvider {return false}
    if lhs.namedMapSettings != rhs.namedMapSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.MapArea: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.protoMessageName + ".MapArea"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "epoch"),
    3: .standard(proto: "map_provider"),
    4: .standard(proto: "bounding_rect"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.epoch) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.mapProvider) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.boundingRect) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 1)
    }
    if self.epoch != 0 {
      try visitor.visitSingularInt32Field(value: self.epoch, fieldNumber: 2)
    }
    if !self.mapProvider.isEmpty {
      try visitor.visitSingularStringField(value: self.mapProvider, fieldNumber: 3)
    }
    if !self.boundingRect.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.boundingRect, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.MapArea, rhs: POGOProtos_Data_Map_MapCompositionRoot.MapArea) -> Bool {
    if lhs.description_p != rhs.description_p {return false}
    if lhs.epoch != rhs.epoch {return false}
    if lhs.mapProvider != rhs.mapProvider {return false}
    if lhs.boundingRect != rhs.boundingRect {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.MapArea.BoundingRect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.MapArea.protoMessageName + ".BoundingRect"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "north"),
    2: .same(proto: "south"),
    3: .same(proto: "east"),
    4: .same(proto: "west"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.north) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.south) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.east) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.west) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.north != 0 {
      try visitor.visitSingularDoubleField(value: self.north, fieldNumber: 1)
    }
    if self.south != 0 {
      try visitor.visitSingularDoubleField(value: self.south, fieldNumber: 2)
    }
    if self.east != 0 {
      try visitor.visitSingularDoubleField(value: self.east, fieldNumber: 3)
    }
    if self.west != 0 {
      try visitor.visitSingularDoubleField(value: self.west, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.MapArea.BoundingRect, rhs: POGOProtos_Data_Map_MapCompositionRoot.MapArea.BoundingRect) -> Bool {
    if lhs.north != rhs.north {return false}
    if lhs.south != rhs.south {return false}
    if lhs.east != rhs.east {return false}
    if lhs.west != rhs.west {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.MapProvider: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.protoMessageName + ".MapProvider"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "base_url"),
    3: .standard(proto: "query_format"),
    6: .standard(proto: "map_type"),
    7: .standard(proto: "hide_attribution"),
    8: .standard(proto: "min_tile_level"),
    9: .standard(proto: "max_tile_level"),
    10: .standard(proto: "bundle_zoom_range"),
    4: .standard(proto: "gmm_settings"),
    5: .standard(proto: "settings_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.baseURL) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.queryFormat) }()
      case 4: try {
        var v: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings?
        if let current = self.settings {
          try decoder.handleConflictingOneOf()
          if case .gmmSettings(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.settings = .gmmSettings(v)}
      }()
      case 5: try {
        if self.settings != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.settings = .settingsName(v)}
      }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.mapType) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.hideAttribution) }()
      case 8: try { try decoder.decodeSingularInt32Field(value: &self.minTileLevel) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.maxTileLevel) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.bundleZoomRange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.baseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.baseURL, fieldNumber: 2)
    }
    if !self.queryFormat.isEmpty {
      try visitor.visitSingularStringField(value: self.queryFormat, fieldNumber: 3)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.settings {
    case .gmmSettings?: try {
      guard case .gmmSettings(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .settingsName?: try {
      guard case .settingsName(let v)? = self.settings else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if self.mapType != .unset {
      try visitor.visitSingularEnumField(value: self.mapType, fieldNumber: 6)
    }
    if self.hideAttribution != false {
      try visitor.visitSingularBoolField(value: self.hideAttribution, fieldNumber: 7)
    }
    if self.minTileLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.minTileLevel, fieldNumber: 8)
    }
    if self.maxTileLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTileLevel, fieldNumber: 9)
    }
    if !self.bundleZoomRange.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bundleZoomRange, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.MapProvider, rhs: POGOProtos_Data_Map_MapCompositionRoot.MapProvider) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.baseURL != rhs.baseURL {return false}
    if lhs.queryFormat != rhs.queryFormat {return false}
    if lhs.mapType != rhs.mapType {return false}
    if lhs.hideAttribution != rhs.hideAttribution {return false}
    if lhs.minTileLevel != rhs.minTileLevel {return false}
    if lhs.maxTileLevel != rhs.maxTileLevel {return false}
    if lhs.bundleZoomRange != rhs.bundleZoomRange {return false}
    if lhs.settings != rhs.settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.MapProvider.MapType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "GMM"),
    2: .same(proto: "OSM"),
    3: .same(proto: "BLANK"),
    4: .same(proto: "GMM_BUNDLE"),
  ]
}

extension POGOProtos_Data_Map_MapCompositionRoot.MapProvider.BundleZoomRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.MapProvider.protoMessageName + ".BundleZoomRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_zoom"),
    2: .standard(proto: "max_zoom"),
    3: .standard(proto: "request_zoom_offset"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minZoom) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxZoom) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.requestZoomOffset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.minZoom, fieldNumber: 1)
    }
    if self.maxZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.maxZoom, fieldNumber: 2)
    }
    if self.requestZoomOffset != 0 {
      try visitor.visitSingularInt32Field(value: self.requestZoomOffset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.MapProvider.BundleZoomRange, rhs: POGOProtos_Data_Map_MapCompositionRoot.MapProvider.BundleZoomRange) -> Bool {
    if lhs.minZoom != rhs.minZoom {return false}
    if lhs.maxZoom != rhs.maxZoom {return false}
    if lhs.requestZoomOffset != rhs.requestZoomOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.NamedMapSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.protoMessageName + ".NamedMapSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "gmm_settings"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gmmSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._gmmSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.NamedMapSettings, rhs: POGOProtos_Data_Map_MapCompositionRoot.NamedMapSettings) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._gmmSettings != rhs._gmmSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.protoMessageName + ".GmmSettings"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "layer_rules"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.layerRules) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.layerRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.layerRules, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings, rhs: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings) -> Bool {
    if lhs.layerRules != rhs.layerRules {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.protoMessageName + ".LayerRule"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fill_colors"),
    2: .standard(proto: "road_priority"),
    3: .standard(proto: "road_attribute_bitfield"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.fillColors) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.roadPriority) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.roadAttributeBitfield) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fillColors.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fillColors, fieldNumber: 1)
    }
    if !self.roadPriority.isEmpty {
      try visitor.visitPackedEnumField(value: self.roadPriority, fieldNumber: 2)
    }
    if self.roadAttributeBitfield != 0 {
      try visitor.visitSingularUInt32Field(value: self.roadAttributeBitfield, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule, rhs: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule) -> Bool {
    if lhs.fillColors != rhs.fillColors {return false}
    if lhs.roadPriority != rhs.roadPriority {return false}
    if lhs.roadAttributeBitfield != rhs.roadAttributeBitfield {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmLayerType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AREA"),
    1: .same(proto: "ROAD"),
    2: .same(proto: "BUILDING"),
    3: .same(proto: "LINE_MESH"),
  ]
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.GmmRoadPriority: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PRIORITY_NONE"),
    1: .same(proto: "PRIORITY_TERMINAL"),
    2: .same(proto: "PRIORITY_LOCAL"),
    3: .same(proto: "PRIORITY_MINOR_ARTERIAL"),
    4: .same(proto: "PRIORITY_MAJOR_ARTERIAL"),
    5: .same(proto: "PRIORITY_SECONDARY_ROAD"),
    6: .same(proto: "PRIORITY_PRIMARY_HIGHWAY"),
    7: .same(proto: "PRIORITY_LIMITED_ACCESS"),
    8: .same(proto: "PRIORITY_CONTROLLED_ACCESS"),
    9: .same(proto: "PRIORITY_NON_TRAFFIC"),
  ]
}

extension POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.MaskedColor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.protoMessageName + ".MaskedColor"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "color_argb"),
    2: .standard(proto: "color_mask_argb"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.colorArgb) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.colorMaskArgb) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.colorArgb != 0 {
      try visitor.visitSingularUInt32Field(value: self.colorArgb, fieldNumber: 1)
    }
    if self.colorMaskArgb != 0 {
      try visitor.visitSingularUInt32Field(value: self.colorMaskArgb, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.MaskedColor, rhs: POGOProtos_Data_Map_MapCompositionRoot.GmmSettings.LayerRule.MaskedColor) -> Bool {
    if lhs.colorArgb != rhs.colorArgb {return false}
    if lhs.colorMaskArgb != rhs.colorMaskArgb {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_LabelTile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LabelTile"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "labels"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.labels) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.labels.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.labels, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_LabelTile, rhs: POGOProtos_Data_Map_LabelTile) -> Bool {
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_LabelTile.Label: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_LabelTile.protoMessageName + ".Label"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "priority"),
    2: .same(proto: "geometry"),
    3: .same(proto: "content"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.priority) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._geometry) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.priority != 0 {
      try visitor.visitSingularInt32Field(value: self.priority, fieldNumber: 1)
    }
    if let v = self._geometry {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._content {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_LabelTile.Label, rhs: POGOProtos_Data_Map_LabelTile.Label) -> Bool {
    if lhs.priority != rhs.priority {return false}
    if lhs._geometry != rhs._geometry {return false}
    if lhs._content != rhs._content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_LabelTile.Label.LabelGeometry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_LabelTile.Label.protoMessageName + ".LabelGeometry"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
    2: .standard(proto: "min_zoom"),
    3: .standard(proto: "max_zoom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._point) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.minZoom) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxZoom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._point {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.minZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.minZoom, fieldNumber: 2)
    }
    if self.maxZoom != 0 {
      try visitor.visitSingularInt32Field(value: self.maxZoom, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry, rhs: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry) -> Bool {
    if lhs._point != rhs._point {return false}
    if lhs.minZoom != rhs.minZoom {return false}
    if lhs.maxZoom != rhs.maxZoom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.PixelPoint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.protoMessageName + ".PixelPoint"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pixel_x"),
    2: .standard(proto: "pixel_y"),
    3: .standard(proto: "zoom_level"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pixelX) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pixelY) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.zoomLevel) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pixelX != 0 {
      try visitor.visitSingularInt32Field(value: self.pixelX, fieldNumber: 1)
    }
    if self.pixelY != 0 {
      try visitor.visitSingularInt32Field(value: self.pixelY, fieldNumber: 2)
    }
    if self.zoomLevel != 0 {
      try visitor.visitSingularInt32Field(value: self.zoomLevel, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.PixelPoint, rhs: POGOProtos_Data_Map_LabelTile.Label.LabelGeometry.PixelPoint) -> Bool {
    if lhs.pixelX != rhs.pixelX {return false}
    if lhs.pixelY != rhs.pixelY {return false}
    if lhs.zoomLevel != rhs.zoomLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_LabelTile.Label.LabelContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_LabelTile.Label.protoMessageName + ".LabelContent"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localizations"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.localizations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localizations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.localizations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_LabelTile.Label.LabelContent, rhs: POGOProtos_Data_Map_LabelTile.Label.LabelContent) -> Bool {
    if lhs.localizations != rhs.localizations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Data_Map_LabelTile.Label.LabelContent.LabelContentLocalization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Data_Map_LabelTile.Label.LabelContent.protoMessageName + ".LabelContentLocalization"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
    2: .same(proto: "name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Data_Map_LabelTile.Label.LabelContent.LabelContentLocalization, rhs: POGOProtos_Data_Map_LabelTile.Label.LabelContent.LabelContentLocalization) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
