// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: POGOProtos/Networking/Responses/GetTodayViewResponse.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct POGOProtos_Networking_Responses_GetTodayViewResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: POGOProtos_Networking_Responses_GetTodayViewResponse.Status = .unset

  public var todayView: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView {
    get {return _todayView ?? POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView()}
    set {_todayView = newValue}
  }
  /// Returns true if `todayView` has been explicitly set.
  public var hasTodayView: Bool {return self._todayView != nil}
  /// Clears the value of `todayView`. Subsequent reads from it will return its default value.
  public mutating func clearTodayView() {self._todayView = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case unset // = 0
    case success // = 1
    case error // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unset
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unset
      case 1: self = .success
      case 2: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unset: return 0
      case .success: return 1
      case .error: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct TodayView {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var sections: [POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct TodayViewSection {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var section: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.OneOf_Section? = nil

      public var pokecoin: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection {
        get {
          if case .pokecoin(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection()
        }
        set {section = .pokecoin(newValue)}
      }

      public var gymPokemon: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection {
        get {
          if case .gymPokemon(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection()
        }
        set {section = .gymPokemon(newValue)}
      }

      public var streaks: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks {
        get {
          if case .streaks(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks()
        }
        set {section = .streaks(newValue)}
      }

      public var event: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection {
        get {
          if case .event(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection()
        }
        set {section = .event(newValue)}
      }

      public var upNext: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection {
        get {
          if case .upNext(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection()
        }
        set {section = .upNext(newValue)}
      }

      public var timedQuest: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection {
        get {
          if case .timedQuest(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection()
        }
        set {section = .timedQuest(newValue)}
      }

      public var eventBanner: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection {
        get {
          if case .eventBanner(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection()
        }
        set {section = .eventBanner(newValue)}
      }

      public var timedGroupChallenge: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection {
        get {
          if case .timedGroupChallenge(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection()
        }
        set {section = .timedGroupChallenge(newValue)}
      }

      public var miniCollection: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection {
        get {
          if case .miniCollection(let v)? = section {return v}
          return POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection()
        }
        set {section = .miniCollection(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Section: Equatable {
        case pokecoin(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection)
        case gymPokemon(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection)
        case streaks(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks)
        case event(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection)
        case upNext(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection)
        case timedQuest(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection)
        case eventBanner(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection)
        case timedGroupChallenge(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection)
        case miniCollection(POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection)

      #if !swift(>=4.1)
        public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.OneOf_Section, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.OneOf_Section) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.pokecoin, .pokecoin): return {
            guard case .pokecoin(let l) = lhs, case .pokecoin(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.gymPokemon, .gymPokemon): return {
            guard case .gymPokemon(let l) = lhs, case .gymPokemon(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.streaks, .streaks): return {
            guard case .streaks(let l) = lhs, case .streaks(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.event, .event): return {
            guard case .event(let l) = lhs, case .event(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.upNext, .upNext): return {
            guard case .upNext(let l) = lhs, case .upNext(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.timedQuest, .timedQuest): return {
            guard case .timedQuest(let l) = lhs, case .timedQuest(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.eventBanner, .eventBanner): return {
            guard case .eventBanner(let l) = lhs, case .eventBanner(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.timedGroupChallenge, .timedGroupChallenge): return {
            guard case .timedGroupChallenge(let l) = lhs, case .timedGroupChallenge(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.miniCollection, .miniCollection): return {
            guard case .miniCollection(let l) = lhs, case .miniCollection(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      public struct MiniCollectionSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var questID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct TimedGroupChallengeSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var challengeID: String = String()

        public var headerImageURL: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct EventBannerSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var eventIcon: String = String()

        public var titleText: String = String()

        public var bodyText: String = String()

        public var imageURL: String = String()

        public var headerImageURL: String = String()

        public var imageOverlayText: String = String()

        public var linkFromImage: String = String()

        public var imageSubText: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct TimedQuestSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var questID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct DailyStreaks {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var streaks: [POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks.Streak] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct Streak {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var questType: POGOProtos_Enums_QuestType = .questUnknownType

          public var count: Int32 = 0

          public var target: Int32 = 0

          public var remainingToday: Int32 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}
      }

      public struct EventSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var eventName: String = String()

        public var endTime: POGOProtos_Networking_Responses_GetLocalTimeResponse.LocalTime {
          get {return _endTime ?? POGOProtos_Networking_Responses_GetLocalTimeResponse.LocalTime()}
          set {_endTime = newValue}
        }
        /// Returns true if `endTime` has been explicitly set.
        public var hasEndTime: Bool {return self._endTime != nil}
        /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
        public mutating func clearEndTime() {self._endTime = nil}

        public var refNewsID: String = String()

        public var bonusBoxes: [POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct BonusBox {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var text: String = String()

          public var iconType: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox.IconType = .unset

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public enum IconType: SwiftProtobuf.Enum {
            public typealias RawValue = Int
            case unset // = 0
            case adventureSync // = 1
            case buddy // = 2
            case candyGeneral // = 3
            case egg // = 4
            case eggIncubator // = 5
            case eventMove // = 6
            case evolution // = 7
            case fieldResearch // = 8
            case friendship // = 9
            case gift // = 10
            case incense // = 11
            case luckyEgg // = 12
            case lureModule // = 13
            case photobomb // = 14
            case pokestop // = 15
            case raid // = 16
            case raidPass // = 17
            case spawnUnknown // = 18
            case starPiece // = 19
            case stardust // = 20
            case teamRocket // = 21
            case trade // = 22
            case transferCandy // = 23
            case battle // = 24
            case xp // = 25
            case shop // = 26
            case location // = 27
            case event // = 28
            case mysteryBox // = 29
            case tradeBall // = 30
            case UNRECOGNIZED(Int)

            public init() {
              self = .unset
            }

            public init?(rawValue: Int) {
              switch rawValue {
              case 0: self = .unset
              case 1: self = .adventureSync
              case 2: self = .buddy
              case 3: self = .candyGeneral
              case 4: self = .egg
              case 5: self = .eggIncubator
              case 6: self = .eventMove
              case 7: self = .evolution
              case 8: self = .fieldResearch
              case 9: self = .friendship
              case 10: self = .gift
              case 11: self = .incense
              case 12: self = .luckyEgg
              case 13: self = .lureModule
              case 14: self = .photobomb
              case 15: self = .pokestop
              case 16: self = .raid
              case 17: self = .raidPass
              case 18: self = .spawnUnknown
              case 19: self = .starPiece
              case 20: self = .stardust
              case 21: self = .teamRocket
              case 22: self = .trade
              case 23: self = .transferCandy
              case 24: self = .battle
              case 25: self = .xp
              case 26: self = .shop
              case 27: self = .location
              case 28: self = .event
              case 29: self = .mysteryBox
              case 30: self = .tradeBall
              default: self = .UNRECOGNIZED(rawValue)
              }
            }

            public var rawValue: Int {
              switch self {
              case .unset: return 0
              case .adventureSync: return 1
              case .buddy: return 2
              case .candyGeneral: return 3
              case .egg: return 4
              case .eggIncubator: return 5
              case .eventMove: return 6
              case .evolution: return 7
              case .fieldResearch: return 8
              case .friendship: return 9
              case .gift: return 10
              case .incense: return 11
              case .luckyEgg: return 12
              case .lureModule: return 13
              case .photobomb: return 14
              case .pokestop: return 15
              case .raid: return 16
              case .raidPass: return 17
              case .spawnUnknown: return 18
              case .starPiece: return 19
              case .stardust: return 20
              case .teamRocket: return 21
              case .trade: return 22
              case .transferCandy: return 23
              case .battle: return 24
              case .xp: return 25
              case .shop: return 26
              case .location: return 27
              case .event: return 28
              case .mysteryBox: return 29
              case .tradeBall: return 30
              case .UNRECOGNIZED(let i): return i
              }
            }

          }

          public init() {}
        }

        public init() {}

        fileprivate var _endTime: POGOProtos_Networking_Responses_GetLocalTimeResponse.LocalTime? = nil
      }

      public struct UpNextSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var eventID: [String] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct PokecoinSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var coinsEarnedToday: Int32 = 0

        public var maxCoinsPerDay: Int32 = 0

        public var coinsQuestID: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct GymPokemonSection {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var pokemonInGym: [POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection.GymPokemon] = []

        public var pokemonReturnedToday: [POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection.GymPokemon] = []

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public struct GymPokemon {
          // SwiftProtobuf.Message conformance is added in an extension below. See the
          // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
          // methods supported on all messages.

          public var pokemonID: Int64 = 0

          public var motivation: Float = 0

          public var deployedTimestampMs: Int64 = 0

          public var coinsReturned: Int32 = 0

          public var unknownFields = SwiftProtobuf.UnknownStorage()

          public init() {}
        }

        public init() {}
      }

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _todayView: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView? = nil
}

#if swift(>=4.2)

extension POGOProtos_Networking_Responses_GetTodayViewResponse.Status: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Networking_Responses_GetTodayViewResponse.Status] = [
    .unset,
    .success,
    .error,
  ]
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox.IconType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox.IconType] = [
    .unset,
    .adventureSync,
    .buddy,
    .candyGeneral,
    .egg,
    .eggIncubator,
    .eventMove,
    .evolution,
    .fieldResearch,
    .friendship,
    .gift,
    .incense,
    .luckyEgg,
    .lureModule,
    .photobomb,
    .pokestop,
    .raid,
    .raidPass,
    .spawnUnknown,
    .starPiece,
    .stardust,
    .teamRocket,
    .trade,
    .transferCandy,
    .battle,
    .xp,
    .shop,
    .location,
    .event,
    .mysteryBox,
    .tradeBall,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "POGOProtos.Networking.Responses"

extension POGOProtos_Networking_Responses_GetTodayViewResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetTodayViewResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .standard(proto: "today_view"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._todayView) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unset {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    if let v = self._todayView {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._todayView != rhs._todayView {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "ERROR"),
  ]
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.protoMessageName + ".TodayView"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sections"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView) -> Bool {
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.protoMessageName + ".TodayViewSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pokecoin"),
    2: .standard(proto: "gym_pokemon"),
    3: .same(proto: "streaks"),
    4: .same(proto: "event"),
    5: .standard(proto: "up_next"),
    6: .standard(proto: "timed_quest"),
    7: .standard(proto: "event_banner"),
    8: .standard(proto: "timed_group_challenge"),
    9: .standard(proto: "mini_collection"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .pokecoin(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .pokecoin(v)}
      }()
      case 2: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .gymPokemon(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .gymPokemon(v)}
      }()
      case 3: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .streaks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .streaks(v)}
      }()
      case 4: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .event(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .event(v)}
      }()
      case 5: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .upNext(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .upNext(v)}
      }()
      case 6: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .timedQuest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .timedQuest(v)}
      }()
      case 7: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .eventBanner(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .eventBanner(v)}
      }()
      case 8: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .timedGroupChallenge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .timedGroupChallenge(v)}
      }()
      case 9: try {
        var v: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection?
        if let current = self.section {
          try decoder.handleConflictingOneOf()
          if case .miniCollection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.section = .miniCollection(v)}
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.section {
    case .pokecoin?: try {
      guard case .pokecoin(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .gymPokemon?: try {
      guard case .gymPokemon(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .streaks?: try {
      guard case .streaks(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .event?: try {
      guard case .event(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .upNext?: try {
      guard case .upNext(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .timedQuest?: try {
      guard case .timedQuest(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .eventBanner?: try {
      guard case .eventBanner(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .timedGroupChallenge?: try {
      guard case .timedGroupChallenge(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .miniCollection?: try {
      guard case .miniCollection(let v)? = self.section else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection) -> Bool {
    if lhs.section != rhs.section {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".MiniCollectionSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quest_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.questID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.questID.isEmpty {
      try visitor.visitSingularStringField(value: self.questID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.MiniCollectionSection) -> Bool {
    if lhs.questID != rhs.questID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".TimedGroupChallengeSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "challenge_id"),
    2: .standard(proto: "header_image_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.challengeID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.headerImageURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.challengeID.isEmpty {
      try visitor.visitSingularStringField(value: self.challengeID, fieldNumber: 1)
    }
    if !self.headerImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.headerImageURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedGroupChallengeSection) -> Bool {
    if lhs.challengeID != rhs.challengeID {return false}
    if lhs.headerImageURL != rhs.headerImageURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".EventBannerSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_icon"),
    2: .standard(proto: "title_text"),
    3: .standard(proto: "body_text"),
    4: .standard(proto: "image_url"),
    5: .standard(proto: "header_image_url"),
    6: .standard(proto: "image_overlay_text"),
    7: .standard(proto: "link_from_image"),
    8: .standard(proto: "image_sub_text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventIcon) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.titleText) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.bodyText) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imageURL) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.headerImageURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageOverlayText) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.linkFromImage) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.imageSubText) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventIcon.isEmpty {
      try visitor.visitSingularStringField(value: self.eventIcon, fieldNumber: 1)
    }
    if !self.titleText.isEmpty {
      try visitor.visitSingularStringField(value: self.titleText, fieldNumber: 2)
    }
    if !self.bodyText.isEmpty {
      try visitor.visitSingularStringField(value: self.bodyText, fieldNumber: 3)
    }
    if !self.imageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.imageURL, fieldNumber: 4)
    }
    if !self.headerImageURL.isEmpty {
      try visitor.visitSingularStringField(value: self.headerImageURL, fieldNumber: 5)
    }
    if !self.imageOverlayText.isEmpty {
      try visitor.visitSingularStringField(value: self.imageOverlayText, fieldNumber: 6)
    }
    if !self.linkFromImage.isEmpty {
      try visitor.visitSingularStringField(value: self.linkFromImage, fieldNumber: 7)
    }
    if !self.imageSubText.isEmpty {
      try visitor.visitSingularStringField(value: self.imageSubText, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventBannerSection) -> Bool {
    if lhs.eventIcon != rhs.eventIcon {return false}
    if lhs.titleText != rhs.titleText {return false}
    if lhs.bodyText != rhs.bodyText {return false}
    if lhs.imageURL != rhs.imageURL {return false}
    if lhs.headerImageURL != rhs.headerImageURL {return false}
    if lhs.imageOverlayText != rhs.imageOverlayText {return false}
    if lhs.linkFromImage != rhs.linkFromImage {return false}
    if lhs.imageSubText != rhs.imageSubText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".TimedQuestSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quest_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.questID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.questID.isEmpty {
      try visitor.visitSingularStringField(value: self.questID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.TimedQuestSection) -> Bool {
    if lhs.questID != rhs.questID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".DailyStreaks"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "streaks"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.streaks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.streaks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.streaks, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks) -> Bool {
    if lhs.streaks != rhs.streaks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks.Streak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks.protoMessageName + ".Streak"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "quest_type"),
    2: .same(proto: "count"),
    3: .same(proto: "target"),
    4: .standard(proto: "remaining_today"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.questType) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.target) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.remainingToday) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.questType != .questUnknownType {
      try visitor.visitSingularEnumField(value: self.questType, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 2)
    }
    if self.target != 0 {
      try visitor.visitSingularInt32Field(value: self.target, fieldNumber: 3)
    }
    if self.remainingToday != 0 {
      try visitor.visitSingularInt32Field(value: self.remainingToday, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks.Streak, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.DailyStreaks.Streak) -> Bool {
    if lhs.questType != rhs.questType {return false}
    if lhs.count != rhs.count {return false}
    if lhs.target != rhs.target {return false}
    if lhs.remainingToday != rhs.remainingToday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".EventSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_name"),
    3: .standard(proto: "end_time"),
    4: .standard(proto: "ref_news_id"),
    5: .standard(proto: "bonus_boxes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.eventName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.refNewsID) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.bonusBoxes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventName.isEmpty {
      try visitor.visitSingularStringField(value: self.eventName, fieldNumber: 1)
    }
    if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.refNewsID.isEmpty {
      try visitor.visitSingularStringField(value: self.refNewsID, fieldNumber: 4)
    }
    if !self.bonusBoxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.bonusBoxes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection) -> Bool {
    if lhs.eventName != rhs.eventName {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.refNewsID != rhs.refNewsID {return false}
    if lhs.bonusBoxes != rhs.bonusBoxes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.protoMessageName + ".BonusBox"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "icon_type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.iconType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.iconType != .unset {
      try visitor.visitSingularEnumField(value: self.iconType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.iconType != rhs.iconType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.EventSection.BonusBox.IconType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSET"),
    1: .same(proto: "ADVENTURE_SYNC"),
    2: .same(proto: "BUDDY"),
    3: .same(proto: "CANDY_GENERAL"),
    4: .same(proto: "EGG"),
    5: .same(proto: "EGG_INCUBATOR"),
    6: .same(proto: "EVENT_MOVE"),
    7: .same(proto: "EVOLUTION"),
    8: .same(proto: "FIELD_RESEARCH"),
    9: .same(proto: "FRIENDSHIP"),
    10: .same(proto: "GIFT"),
    11: .same(proto: "INCENSE"),
    12: .same(proto: "LUCKY_EGG"),
    13: .same(proto: "LURE_MODULE"),
    14: .same(proto: "PHOTOBOMB"),
    15: .same(proto: "POKESTOP"),
    16: .same(proto: "RAID"),
    17: .same(proto: "RAID_PASS"),
    18: .same(proto: "SPAWN_UNKNOWN"),
    19: .same(proto: "STAR_PIECE"),
    20: .same(proto: "STARDUST"),
    21: .same(proto: "TEAM_ROCKET"),
    22: .same(proto: "TRADE"),
    23: .same(proto: "TRANSFER_CANDY"),
    24: .same(proto: "BATTLE"),
    25: .same(proto: "XP"),
    26: .same(proto: "SHOP"),
    27: .same(proto: "LOCATION"),
    28: .same(proto: "EVENT"),
    29: .same(proto: "MYSTERY_BOX"),
    30: .same(proto: "TRADE_BALL"),
  ]
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".UpNextSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.eventID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.eventID.isEmpty {
      try visitor.visitRepeatedStringField(value: self.eventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.UpNextSection) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".PokecoinSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "coins_earned_today"),
    2: .standard(proto: "max_coins_per_day"),
    3: .standard(proto: "coins_quest_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.coinsEarnedToday) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxCoinsPerDay) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.coinsQuestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coinsEarnedToday != 0 {
      try visitor.visitSingularInt32Field(value: self.coinsEarnedToday, fieldNumber: 1)
    }
    if self.maxCoinsPerDay != 0 {
      try visitor.visitSingularInt32Field(value: self.maxCoinsPerDay, fieldNumber: 2)
    }
    if !self.coinsQuestID.isEmpty {
      try visitor.visitSingularStringField(value: self.coinsQuestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.PokecoinSection) -> Bool {
    if lhs.coinsEarnedToday != rhs.coinsEarnedToday {return false}
    if lhs.maxCoinsPerDay != rhs.maxCoinsPerDay {return false}
    if lhs.coinsQuestID != rhs.coinsQuestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.protoMessageName + ".GymPokemonSection"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pokemon_in_gym"),
    2: .standard(proto: "pokemon_returned_today"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pokemonInGym) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pokemonReturnedToday) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pokemonInGym.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pokemonInGym, fieldNumber: 1)
    }
    if !self.pokemonReturnedToday.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pokemonReturnedToday, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection) -> Bool {
    if lhs.pokemonInGym != rhs.pokemonInGym {return false}
    if lhs.pokemonReturnedToday != rhs.pokemonReturnedToday {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection.GymPokemon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection.protoMessageName + ".GymPokemon"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pokemon_id"),
    2: .same(proto: "motivation"),
    3: .standard(proto: "deployed_timestamp_ms"),
    4: .standard(proto: "coins_returned"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.pokemonID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.motivation) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.deployedTimestampMs) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.coinsReturned) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pokemonID != 0 {
      try visitor.visitSingularInt64Field(value: self.pokemonID, fieldNumber: 1)
    }
    if self.motivation != 0 {
      try visitor.visitSingularFloatField(value: self.motivation, fieldNumber: 2)
    }
    if self.deployedTimestampMs != 0 {
      try visitor.visitSingularInt64Field(value: self.deployedTimestampMs, fieldNumber: 3)
    }
    if self.coinsReturned != 0 {
      try visitor.visitSingularInt32Field(value: self.coinsReturned, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection.GymPokemon, rhs: POGOProtos_Networking_Responses_GetTodayViewResponse.TodayView.TodayViewSection.GymPokemonSection.GymPokemon) -> Bool {
    if lhs.pokemonID != rhs.pokemonID {return false}
    if lhs.motivation != rhs.motivation {return false}
    if lhs.deployedTimestampMs != rhs.deployedTimestampMs {return false}
    if lhs.coinsReturned != rhs.coinsReturned {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
